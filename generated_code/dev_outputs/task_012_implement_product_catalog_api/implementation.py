An architectural overview and detailed setup instructions are provided below, followed by the complete source code for the Product Catalog API.

## Architecture & Design

The service is built using a modern Python backend stack, designed for scalability, maintainability, and performance.

### 1. **Technology Stack**
- **Backend Framework**: **FastAPI** is used for its high performance, asynchronous capabilities, and automatic OpenAPI documentation.
- **Database**: **PostgreSQL** is the chosen relational database for its robustness and feature set.
- **ORM**: **SQLAlchemy 2.0** (asyncio) provides a powerful and flexible Object-Relational Mapper for interacting with the database asynchronously.
- **Data Validation**: **Pydantic** is used for data validation, serialization, and settings management, integrating seamlessly with FastAPI.
- **Database Migrations**: **Alembic** handles database schema migrations, allowing for version-controlled changes to the database structure.
- **Containerization**: **Docker** and **Docker Compose** are used to create a consistent, isolated, and reproducible development and production environment.

### 2. **Project Structure**
The project follows a clean, modular structure to enforce separation of concerns:

- `app/`: Contains the core application logic.
  - `api/`: API-specific modules, including routers and dependencies.
  - `core/`: Core application settings and security logic.
  - `crud/`: Reusable Create, Read, Update, Delete (CRUD) database operations.
  - `db/`: Database session management and base model definitions.
  - `models/`: SQLAlchemy ORM models.
  - `schemas/`: Pydantic data validation schemas.
  - `tests/`: Unit and integration tests.
- `alembic/`: Database migration scripts generated by Alembic.
- `Dockerfile`: Instructions to build the production-ready Docker image.
- `docker-compose.yml`: Defines the services (API, database) for local development.
- `pyproject.toml`: Project metadata and dependencies.

### 3. **Security**
Security is a primary concern and is addressed through multiple layers:

- **Authentication & Authorization**: Endpoints are secured using JWT. A dependency (`get_current_admin_user`) validates the token and checks for an `admin` role for protected routes.
- **Input Validation**: Pydantic schemas automatically validate all incoming request bodies and query parameters, preventing malformed data from being processed.
- **Environment Variables**: All sensitive information (database credentials, JWT secrets) is managed via environment variables and is not hardcoded.
- **SQL Injection Prevention**: The use of an ORM (SQLAlchemy) with parameterized queries effectively mitigates the risk of SQL injection attacks.
- **Health Checks**: A `/health` endpoint is provided for monitoring and load balancer health checks.

### 4. **Performance & Scalability**
- **Asynchronous Operations**: The entire request-response cycle, including database queries, is asynchronous, allowing the server to handle a high number of concurrent connections efficiently.
- **Pagination**: All list endpoints are paginated to prevent overwhelming the client and database with large datasets.
- **Scalability**: The stateless nature of the API and its containerization with Docker allow for easy horizontal scaling by running multiple instances behind a load balancer.

## Setup and Deployment Instructions

### Prerequisites
- Docker
- Docker Compose

### 1. **Environment Configuration**
Create a `.env` file in the project root by copying the example file:
```bash
cp .env.example .env
```
Update the `.env` file with your desired settings. **It is critical to change `SECRET_KEY` to a new, strong, randomly generated string for production.**

### 2. **Build and Run with Docker Compose**
This command will build the Docker images, start the API and database containers, and apply database migrations automatically.

```bash
docker-compose up --build
```

- The API will be available at `http://localhost:8000`.
- Interactive API documentation (Swagger UI) will be at `http://localhost:8000/docs`.
- Alternative API documentation (ReDoc) will be at `http://localhost:8000/redoc`.

### 3. **Running Tests**
To run the test suite, execute the following command in a separate terminal while the application is running:

```bash
docker-compose exec api pytest
```

### 4. **Generating JWT for Admin Access**
To access admin-only endpoints, you need a valid JWT with an `admin` role. For demonstration purposes, you can generate one using an online tool like [jwt.io](https://jwt.io/).

**Header:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Payload:**
Set the `exp` (expiration time) to a future timestamp. The `sub` can be any user identifier. The `role` **must be 'admin'**.
```json
{
  "sub": "1234567890",
  "name": "Admin User",
  "iat": 1516239022,
  "exp": 1735689600,
  "role": "admin"
}
```

**Verify Signature:**
Use the `SECRET_KEY` from your `.env` file to sign the token.

You can then use this token in the "Authorize" section of the Swagger UI (`/docs`) or by passing it as a Bearer token in the `Authorization` header of your API requests.

---
## Code Artifacts

### `pyproject.toml`
This file defines project metadata and dependencies.

```toml
[tool.poetry]
name = "product-catalog-service"
version = "0.1.0"
description = "Product Catalog API with CRUD, search, filtering, and pagination."
authors = ["AI Developer <ai@dev.null>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.111.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}
sqlalchemy = {extras = ["asyncio"], version = "^2.0.30"}
asyncpg = "^0.29.0"
pydantic = {extras = ["email"], version = "^2.7.1"}
pydantic-settings = "^2.2.1"
alembic = "^1.13.1"
python-jose = {extras = ["cryptography"], version = "^3.3.0"}
passlib = {extras = ["bcrypt"], version = "^1.7.4"}
greenlet = "^3.0.3"

[tool.poetry.group.dev.dependencies]
pytest = "^8.2.1"
pytest-asyncio = "^0.23.7"
httpx = "^0.27.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

### `.env.example`
Example environment variables file.

```dotenv
# Application Settings
PROJECT_NAME="Product Catalog API"
API_V1_STR="/api/v1"

# Security
# To generate a new secret key:
# openssl rand -hex 32
SECRET_KEY=09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
ACCESS_TOKEN_EXPIRE_MINUTES=60

# PostgreSQL Database
POSTGRES_SERVER=db
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=product_catalog_db
DATABASE_URL="postgresql+asyncpg://postgres:postgres@db/product_catalog_db"

# Test Database
# Note: The test DB URL should point to a separate database to avoid data corruption.
# For simplicity in this example, we use a different DB on the same server.
# In a real-world scenario, you might use a separate container or an in-memory DB like SQLite for tests.
TEST_POSTGRES_SERVER=db
TEST_POSTGRES_USER=postgres
TEST_POSTGRES_PASSWORD=postgres
TEST_POSTGRES_DB=product_catalog_test_db
TEST_DATABASE_URL="postgresql+asyncpg://postgres:postgres@db/product_catalog_test_db"
```

### `Dockerfile`
Multi-stage Dockerfile for a lean and secure production image.

```dockerfile
# Stage 1: Build stage with development dependencies
FROM python:3.11-slim as builder

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

WORKDIR /app

# Install poetry
RUN pip install poetry

# Copy only dependency definition files
COPY pyproject.toml poetry.lock ./

# Install project dependencies (without dev dependencies)
RUN poetry config virtualenvs.create false && \
    poetry install --no-dev --no-interaction --no-ansi

# Stage 2: Final production stage
FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

WORKDIR /app

# Copy virtual environment from builder stage
COPY --from=builder /app/ /app/

# Copy application code
COPY ./app /app/app
COPY ./alembic /app/alembic
COPY ./alembic.ini /app/alembic.ini

# Expose the port the app runs on
EXPOSE 8000

# Command to run the application
# The entrypoint script will handle running migrations before starting the server
COPY ./docker-entrypoint.sh /app/docker-entrypoint.sh
RUN chmod +x /app/docker-entrypoint.sh

ENTRYPOINT ["/app/docker-entrypoint.sh"]
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### `docker-entrypoint.sh`
This script runs database migrations before starting the application server.

```sh
#!/bin/sh

# Exit immediately if a command exits with a non-zero status.
set -e

# Wait for the database to be ready
# This is a simple check; more robust solutions like wait-for-it.sh can be used
echo "Waiting for postgres..."
while ! nc -z $POSTGRES_SERVER 5432; do
  sleep 0.1
done
echo "PostgreSQL started"

# Run database migrations
echo "Running database migrations..."
alembic upgrade head

# Execute the command passed to this script (e.g., uvicorn)
exec "$@"
```

### `docker-compose.yml`
Docker Compose file to orchestrate the services.

```yaml
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5

  api:
    build: .
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - ./app:/app/app
    ports:
      - "8000:8000"
    env_file:
      - .env
    depends_on:
      db:
        condition: service_healthy

volumes:
  postgres_data:
```

### `alembic.ini`
Configuration for Alembic database migrations.

```ini
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://user:password@host/db

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
```

### `alembic/env.py`
Alembic environment script, configured for async and to read from `core.config`.

```python
import asyncio
from logging.config import fileConfig

from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
from app.db.base import Base  # noqa
from app.core.config import settings  # noqa
from app.models.category import Category # noqa
from app.models.product import Product # noqa

target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = settings.DATABASE_URL
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    configuration = config.get_section(config.config_ini_section)
    configuration["sqlalchemy.url"] = settings.DATABASE_URL
    connectable = async_engine_from_config(
        configuration,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
```

### `alembic/versions/initial_migration.py`
*This file should be generated by running `alembic revision --autogenerate -m "Initial migration"`. A placeholder is provided.*

```python
"""Initial migration

Revision ID: 1a2b3c4d5e6f
Revises: 
Create Date: 2023-10-27 10:00:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '1a2b3c4d5e6f'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('categories',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.String(length=255), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_categories_id'), 'categories', ['id'], unique=False)
    op.create_index(op.f('ix_categories_name'), 'categories', ['name'], unique=True)
    op.create_table('products',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', sa.Numeric(precision=10, scale=2), nullable=False),
    sa.Column('stock', sa.Integer(), nullable=False),
    sa.Column('category_id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['category_id'], ['categories.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_products_id'), 'products', ['id'], unique=False)
    op.create_index(op.f('ix_products_name'), 'products', ['name'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_products_name'), table_name='products')
    op.drop_index(op.f('ix_products_id'), table_name='products')
    op.drop_table('products')
    op.drop_index(op.f('ix_categories_name'), table_name='categories')
    op.drop_index(op.f('ix_categories_id'), table_name='categories')
    op.drop_table('categories')
    # ### end Alembic commands ###
```

### `app/main.py`
The main FastAPI application entry point.

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.api.v1 import api_router
from app.core.config import settings

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Set all CORS enabled origins
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/health", tags=["Health"])
def health_check():
    """
    Health check endpoint.
    """
    return {"status": "ok"}

```

### `app/core/config.py`
Configuration settings loaded from environment variables using Pydantic.

```python
from pydantic_settings import BaseSettings
from typing import List, Union

class Settings(BaseSettings):
    PROJECT_NAME: str = "Product Catalog API"
    API_V1_STR: str = "/api/v1"
    
    # Security
    SECRET_KEY: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    
    # Database
    POSTGRES_SERVER: str
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_DB: str
    DATABASE_URL: str

    # Test Database
    TEST_DATABASE_URL: str

    # CORS
    BACKEND_CORS_ORIGINS: List[str] = ["*"]

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()
```

### `app/core/security.py`
JWT handling and security utilities.

```python
from datetime import datetime, timedelta, timezone
from typing import Any, Union

from jose import jwt, JWTError
from passlib.context import CryptContext

from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = "HS256"

def create_access_token(
    subject: Union[str, Any], expires_delta: timedelta = None
) -> str:
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def decode_access_token(token: str) -> dict | None:
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

### `app/db/session.py`
Database session setup for SQLAlchemy.

```python
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from app.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True)
AsyncSessionLocal = async_sessionmaker(autocommit=False, autoflush=False, bind=engine)
```

### `app/db/base.py`
Base class for SQLAlchemy models.

```python
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass
```

### `app/models/category.py`
SQLAlchemy model for Category.

```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import relationship

from app.db.base import Base

class Category(Base):
    __tablename__ = "categories"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), unique=True, index=True, nullable=False)
    description = Column(String(255), nullable=True)

    products = relationship("Product", back_populates="category")
```

### `app/models/product.py`
SQLAlchemy model for Product.

```python
from sqlalchemy import Column, Integer, String, Numeric, ForeignKey, DateTime, Text
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.db.base import Base

class Product(Base):
    __tablename__ = "products"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), index=True, nullable=False)
    description = Column(Text, nullable=True)
    price = Column(Numeric(10, 2), nullable=False)
    stock = Column(Integer, nullable=False)
    category_id = Column(Integer, ForeignKey("categories.id"), nullable=False)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)

    category = relationship("Category", back_populates="products")
```

### `app/schemas/category.py`
Pydantic schemas for Category.

```python
from pydantic import BaseModel, ConfigDict

# Shared properties
class CategoryBase(BaseModel):
    name: str
    description: str | None = None

# Properties to receive on item creation
class CategoryCreate(CategoryBase):
    pass

# Properties to receive on item update
class CategoryUpdate(CategoryBase):
    pass

# Properties shared by models stored in DB
class CategoryInDBBase(CategoryBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

# Properties to return to client
class Category(CategoryInDBBase):
    pass
```

### `app/schemas/product.py`
Pydantic schemas for Product.

```python
from pydantic import BaseModel, ConfigDict, Field
from decimal import Decimal
from datetime import datetime
from .category import Category

# Shared properties
class ProductBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: str | None = None
    price: Decimal = Field(..., gt=0, decimal_places=2)
    stock: int = Field(..., ge=0)
    category_id: int

# Properties to receive on item creation
class ProductCreate(ProductBase):
    pass

# Properties to receive on item update
class ProductUpdate(BaseModel):
    name: str | None = Field(None, min_length=1, max_length=100)
    description: str | None = None
    price: Decimal | None = Field(None, gt=0, decimal_places=2)
    stock: int | None = Field(None, ge=0)
    category_id: int | None = None

# Properties shared by models stored in DB
class ProductInDBBase(ProductBase):
    id: int
    created_at: datetime
    updated_at: datetime
    category: Category
    model_config = ConfigDict(from_attributes=True)

# Properties to return to client
class Product(ProductInDBBase):
    pass

# Paginated product list
class ProductPage(BaseModel):
    total: int
    page: int
    size: int
    items: list[Product]
```

### `app/schemas/msg.py`
Pydantic schema for simple message responses.

```python
from pydantic import BaseModel

class Msg(BaseModel):
    msg: str
```

### `app/crud/base.py`
Base class for CRUD operations.

```python
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union

from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from app.db.base import Base

ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)

class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model

    async def get(self, db: AsyncSession, id: Any) -> Optional[ModelType]:
        result = await db.execute(select(self.model).filter(self.model.id == id))
        return result.scalars().first()

    async def get_multi(
        self, db: AsyncSession, *, skip: int = 0, limit: int = 100
    ) -> List[ModelType]:
        result = await db.execute(select(self.model).offset(skip).limit(limit))
        return result.scalars().all()

    async def create(self, db: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType:
        obj_in_data = jsonable_encoder(obj_in)
        db_obj = self.model(**obj_in_data)
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def update(
        self,
        db: AsyncSession,
        *,
        db_obj: ModelType,
        obj_in: Union[UpdateSchemaType, Dict[str, Any]]
    ) -> ModelType:
        obj_data = jsonable_encoder(db_obj)
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.model_dump(exclude_unset=True)
        for field in obj_data:
            if field in update_data:
                setattr(db_obj, field, update_data[field])
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def remove(self, db: AsyncSession, *, id: int) -> ModelType:
        result = await db.execute(select(self.model).filter(self.model.id == id))
        obj = result.scalars().one()
        await db.delete(obj)
        await db.commit()
        return obj
```

### `app/crud/crud_category.py`
CRUD operations for Categories.

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from app.crud.base import CRUDBase
from app.models.category import Category
from app.schemas.category import CategoryCreate, CategoryUpdate

class CRUDCategory(CRUDBase[Category, CategoryCreate, CategoryUpdate]):
    async def get_by_name(self, db: AsyncSession, *, name: str) -> Category | None:
        result = await db.execute(select(Category).filter(Category.name == name))
        return result.scalars().first()

category = CRUDCategory(Category)
```

### `app/crud/crud_product.py`
CRUD operations for Products, including filtering and sorting.

```python
from typing import Any, Dict, Optional
from decimal import Decimal

from sqlalchemy import func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload

from app.crud.base import CRUDBase
from app.models.product import Product
from app.schemas.product import ProductCreate, ProductUpdate

class CRUDProduct(CRUDBase[Product, ProductCreate, ProductUpdate]):
    async def get_multi_with_filter(
        self,
        db: AsyncSession,
        *,
        page: int = 1,
        size: int = 20,
        sort_by: str = "name_asc",
        search: Optional[str] = None,
        category_id: Optional[int] = None,
        min_price: Optional[Decimal] = None,
        max_price: Optional[Decimal] = None,
    ):
        skip = (page - 1) * size
        
        query = select(Product).options(selectinload(Product.category))
        count_query = select(func.count()).select_from(Product)

        if search:
            search_term = f"%{search}%"
            query = query.filter(Product.name.ilike(search_term))
            count_query = count_query.filter(Product.name.ilike(search_term))

        if category_id:
            query = query.filter(Product.category_id == category_id)
            count_query = count_query.filter(Product.category_id == category_id)

        if min_price is not None:
            query = query.filter(Product.price >= min_price)
            count_query = count_query.filter(Product.price >= min_price)

        if max_price is not None:
            query = query.filter(Product.price <= max_price)
            count_query = count_query.filter(Product.price <= max_price)

        # Sorting
        if sort_by == "price_asc":
            query = query.order_by(Product.price.asc())
        elif sort_by == "price_desc":
            query = query.order_by(Product.price.desc())
        elif sort_by == "name_desc":
            query = query.order_by(Product.name.desc())
        else: # Default to name_asc
            query = query.order_by(Product.name.asc())

        total_count_result = await db.execute(count_query)
        total = total_count_result.scalar_one()

        query = query.offset(skip).limit(size)
        items_result = await db.execute(query)
        items = items_result.scalars().all()
        
        return {"items": items, "total": total}

    async def get_with_category(self, db: AsyncSession, id: int) -> Optional[Product]:
        result = await db.execute(
            select(Product).options(selectinload(Product.category)).filter(Product.id == id)
        )
        return result.scalars().first()

product = CRUDProduct(Product)
```

### `app/api/v1.py`
Main API router for version 1.

```python
from fastapi import APIRouter

from app.api.routers import products, categories

api_router = APIRouter()
api_router.include_router(products.router, prefix="/products", tags=["Products"])
api_router.include_router(categories.router, prefix="/categories", tags=["Categories"])
```

### `app/api/deps.py`
API dependencies for database sessions and security.

```python
from typing import Generator, AsyncGenerator

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession

from app.core import security
from app.core.config import settings
from app.db.session import AsyncSessionLocal

reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session

def get_current_admin_user(token: str = Depends(reusable_oauth2)):
    """
    Dependency to get the current user and verify they are an admin.
    In a real app, this would involve a database lookup.
    For this example, we decode the JWT and check for a 'role' claim.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    payload = security.decode_access_token(token)
    if payload is None:
        raise credentials_exception
    
    # In a real user system, you'd fetch the user from DB:
    # user = await crud.user.get(db, id=payload.get("sub"))
    # if not user or not user.is_superuser:
    #     raise HTTPException(status_code=403, detail="The user doesn't have enough privileges")
    
    # Simplified check for this task
    role = payload.get("role")
    if role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="The user doesn't have enough privileges",
        )
    return payload # Returns the token payload for potential use
```

### `app/api/routers/categories.py`
API router for Category endpoints.

```python
from typing import List

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from app import crud, models, schemas
from app.api import deps

router = APIRouter()

@router.get("/", response_model=List[schemas.Category])
async def read_categories(
    db: AsyncSession = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
):
    """
    Retrieve all categories.
    """
    categories = await crud.category.get_multi(db, skip=skip, limit=limit)
    return categories

@router.post(
    "/", 
    response_model=schemas.Category, 
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(deps.get_current_admin_user)]
)
async def create_category(
    *,
    db: AsyncSession = Depends(deps.get_db),
    category_in: schemas.CategoryCreate,
):
    """
    Create new category. (Admin only)
    """
    category = await crud.category.get_by_name(db, name=category_in.name)
    if category:
        raise HTTPException(
            status_code=400,
            detail="The category with this name already exists in the system.",
        )
    category = await crud.category.create(db=db, obj_in=category_in)
    return category

@router.get("/{id}", response_model=schemas.Category)
async def read_category(
    *,
    db: AsyncSession = Depends(deps.get_db),
    id: int,
):
    """
    Get category by ID.
    """
    category = await crud.category.get(db=db, id=id)
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")
    return category

@router.put(
    "/{id}", 
    response_model=schemas.Category,
    dependencies=[Depends(deps.get_current_admin_user)]
)
async def update_category(
    *,
    db: AsyncSession = Depends(deps.get_db),
    id: int,
    category_in: schemas.CategoryUpdate,
):
    """
    Update a category. (Admin only)
    """
    category = await crud.category.get(db=db, id=id)
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")
    category = await crud.category.update(db=db, db_obj=category, obj_in=category_in)
    return category

@router.delete(
    "/{id}", 
    response_model=schemas.Msg,
    dependencies=[Depends(deps.get_current_admin_user)]
)
async def delete_category(
    *,
    db: AsyncSession = Depends(deps.get_db),
    id: int,
):
    """
    Delete a category. (Admin only)
    """
    category = await crud.category.get(db=db, id=id)
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")
    await crud.category.remove(db=db, id=id)
    return {"msg": "Category deleted successfully"}
```

### `app/api/routers/products.py`
API router for Product endpoints.

```python
from typing import Optional
from decimal import Decimal

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession

from app import crud, models, schemas
from app.api import deps

router = APIRouter()

@router.get("/", response_model=schemas.ProductPage)
async def read_products(
    db: AsyncSession = Depends(deps.get_db),
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
    search: Optional[str] = None,
    category_id: Optional[int] = None,
    min_price: Optional[Decimal] = Query(None, ge=0),
    max_price: Optional[Decimal] = Query(None, ge=0),
    sort_by: str = Query("name_asc", enum=["name_asc", "name_desc", "price_asc", "price_desc"]),
):
    """
    Retrieve a paginated list of products with filtering and sorting.
    """
    if max_price is not None and min_price is not None and max_price < min_price:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="max_price cannot be less than min_price."
        )
    
    result = await crud.product.get_multi_with_filter(
        db,
        page=page,
        size=size,
        search=search,
        category_id=category_id,
        min_price=min_price,
        max_price=max_price,
        sort_by=sort_by,
    )
    return schemas.ProductPage(
        total=result["total"],
        page=page,
        size=size,
        items=result["items"]
    )

@router.post(
    "/", 
    response_model=schemas.Product, 
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(deps.get_current_admin_user)]
)
async def create_product(
    *,
    db: AsyncSession = Depends(deps.get_db),
    product_in: schemas.ProductCreate,
):
    """
    Create new product. (Admin only)
    """
    # Check if category exists
    category = await crud.category.get(db, id=product_in.category_id)
    if not category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Category with id {product_in.category_id} not found."
        )
    product = await crud.product.create(db=db, obj_in=product_in)
    # Eager load category for the response
    return await crud.product.get_with_category(db, id=product.id)


@router.get("/{id}", response_model=schemas.Product)
async def read_product(
    *,
    db: AsyncSession = Depends(deps.get_db),
    id: int,
):
    """
    Get product by ID.
    """
    product = await crud.product.get_with_category(db=db, id=id)
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    return product

@router.put(
    "/{id}", 
    response_model=schemas.Product,
    dependencies=[Depends(deps.get_current_admin_user)]
)
async def update_product(
    *,
    db: AsyncSession = Depends(deps.get_db),
    id: int,
    product_in: schemas.ProductUpdate,
):
    """
    Update a product. (Admin only)
    """
    product = await crud.product.get(db=db, id=id)
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    
    if product_in.category_id:
        category = await crud.category.get(db, id=product_in.category_id)
        if not category:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Category with id {product_in.category_id} not found."
            )

    product = await crud.product.update(db=db, db_obj=product, obj_in=product_in)
    return await crud.product.get_with_category(db, id=product.id)

@router.delete(
    "/{id}", 
    response_model=schemas.Msg,
    dependencies=[Depends(deps.get_current_admin_user)]
)
async def delete_product(
    *,
    db: AsyncSession = Depends(deps.get_db),
    id: int,
):
    """
    Delete a product. (Admin only)
    """
    product = await crud.product.get(db=db, id=id)
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    await crud.product.remove(db=db, id=id)
    return {"msg": "Product deleted successfully"}
```

### `app/tests/conftest.py`
Pytest fixtures for setting up the test environment.

```python
import pytest
import pytest_asyncio
from typing import AsyncGenerator

from httpx import AsyncClient
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.pool import NullPool

from app.main import app
from app.core.config import settings
from app.db.base import Base
from app.api.deps import get_db
from app.core.security import create_access_token
from datetime import timedelta

# Create a new async engine for the test database
engine_test = create_async_engine(settings.TEST_DATABASE_URL, poolclass=NullPool)
TestingSessionLocal = async_sessionmaker(autocommit=False, autoflush=False, bind=engine_test)

@pytest_asyncio.fixture(scope="session", autouse=True)
async def setup_database():
    """
    Create and drop the test database tables for the test session.
    """
    async with engine_test.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    async with engine_test.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

async def override_get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency override for using the test database session.
    """
    async with TestingSessionLocal() as session:
        yield session

app.dependency_overrides[get_db] = override_get_db

@pytest_asyncio.fixture(scope="function")
async def client() -> AsyncGenerator[AsyncClient, None]:
    """
    Fixture to get an async test client.
    """
    async with AsyncClient(app=app, base_url="http://test") as c:
        yield c

@pytest.fixture(scope="module")
def admin_token_headers() -> dict[str, str]:
    """
    Fixture to generate a valid admin JWT token.
    """
    token = create_access_token(
        subject="admin_user@test.com",
        expires_delta=timedelta(minutes=30)
    )
    # Add the 'role' claim for our simplified admin check
    from jose import jwt
    decoded = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
    decoded['role'] = 'admin'
    admin_token = jwt.encode(decoded, settings.SECRET_KEY, algorithm="HS256")
    
    return {"Authorization": f"Bearer {admin_token}"}
```

### `app/tests/api/v1/test_categories.py`
Tests for the Category API endpoints.

```python
import pytest
from httpx import AsyncClient
from fastapi import status

pytestmark = pytest.mark.asyncio

async def test_create_category(client: AsyncClient, admin_token_headers: dict):
    response = await client.post(
        f"/api/v1/categories/",
        headers=admin_token_headers,
        json={"name": "Electronics", "description": "Gadgets and devices"},
    )
    assert response.status_code == status.HTTP_201_CREATED
    data = response.json()
    assert data["name"] == "Electronics"
    assert "id" in data

async def test_create_category_duplicate(client: AsyncClient, admin_token_headers: dict):
    await client.post(
        f"/api/v1/categories/",
        headers=admin_token_headers,
        json={"name": "Books", "description": "Fiction and non-fiction"},
    )
    response = await client.post(
        f"/api/v1/categories/",
        headers=admin_token_headers,
        json={"name": "Books", "description": "Fiction and non-fiction"},
    )
    assert response.status_code == status.HTTP_400_BAD_REQUEST

async def test_read_categories(client: AsyncClient):
    response = await client.get("/api/v1/categories/")
    assert response.status_code == status.HTTP_200_OK
    assert isinstance(response.json(), list)

async def test_read_category(client: AsyncClient, admin_token_headers: dict):
    create_response = await client.post(
        f"/api/v1/categories/",
        headers=admin_token_headers,
        json={"name": "Clothing", "description": "Apparel for all seasons"},
    )
    category_id = create_response.json()["id"]

    response = await client.get(f"/api/v1/categories/{category_id}")
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["name"] == "Clothing"
    assert data["id"] == category_id

async def test_read_category_not_found(client: AsyncClient):
    response = await client.get("/api/v1/categories/9999")
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_update_category(client: AsyncClient, admin_token_headers: dict):
    create_response = await client.post(
        f"/api/v1/categories/",
        headers=admin_token_headers,
        json={"name": "Home Goods", "description": "Items for your home"},
    )
    category_id = create_response.json()["id"]

    response = await client.put(
        f"/api/v1/categories/{category_id}",
        headers=admin_token_headers,
        json={"name": "Home & Kitchen", "description": "Updated description"},
    )
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["name"] == "Home & Kitchen"
    assert data["description"] == "Updated description"

async def test_delete_category(client: AsyncClient, admin_token_headers: dict):
    create_response = await client.post(
        f"/api/v1/categories/",
        headers=admin_token_headers,
        json={"name": "To Be Deleted", "description": "This will be removed"},
    )
    category_id = create_response.json()["id"]

    delete_response = await client.delete(
        f"/api/v1/categories/{category_id}", headers=admin_token_headers
    )
    assert delete_response.status_code == status.HTTP_200_OK
    assert delete_response.json() == {"msg": "Category deleted successfully"}

    get_response = await client.get(f"/api/v1/categories/{category_id}")
    assert get_response.status_code == status.HTTP_404_NOT_FOUND
```

### `app/tests/api/v1/test_products.py`
Tests for the Product API endpoints.

```python
import pytest
from httpx import AsyncClient
from fastapi import status

pytestmark = pytest.mark.asyncio

@pytest.fixture(scope="module")
async def setup_category(client: AsyncClient, admin_token_headers: dict):
    response = await client.post(
        "/api/v1/categories/",
        headers=admin_token_headers,
        json={"name": "Test Category", "description": "For product tests"},
    )
    return response.json()

async def test_create_product(client: AsyncClient, admin_token_headers: dict, setup_category: dict):
    category_id = setup_category["id"]
    product_data = {
        "name": "Laptop Pro",
        "description": "A powerful laptop",
        "price": 1299.99,
        "stock": 50,
        "category_id": category_id,
    }
    response = await client.post(
        "/api/v1/products/", headers=admin_token_headers, json=product_data
    )
    assert response.status_code == status.HTTP_201_CREATED
    data = response.json()
    assert data["name"] == "Laptop Pro"
    assert data["category"]["id"] == category_id

async def test_create_product_no_auth(client: AsyncClient, setup_category: dict):
    category_id = setup_category["id"]
    product_data = {
        "name": "Unauthorized Laptop",
        "description": "This should fail",
        "price": 999.99,
        "stock": 10,
        "category_id": category_id,
    }
    response = await client.post("/api/v1/products/", json=product_data)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_read_product(client: AsyncClient, admin_token_headers: dict, setup_category: dict):
    category_id = setup_category["id"]
    product_data = {
        "name": "Mouse",
        "description": "A wireless mouse",
        "price": 25.50,
        "stock": 200,
        "category_id": category_id,
    }
    create_response = await client.post(
        "/api/v1/products/", headers=admin_token_headers, json=product_data
    )
    product_id = create_response.json()["id"]

    response = await client.get(f"/api/v1/products/{product_id}")
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["name"] == "Mouse"
    assert data["id"] == product_id

async def test_read_products_paginated(client: AsyncClient):
    response = await client.get("/api/v1/products/?page=1&size=1")
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["page"] == 1
    assert data["size"] == 1
    assert "total" in data
    assert isinstance(data["items"], list)

async def test_read_products_filtered(client: AsyncClient, admin_token_headers: dict, setup_category: dict):
    category_id = setup_category["id"]
    await client.post(
        "/api/v1/products/",
        headers=admin_token_headers,
        json={
            "name": "Unique Filter Product",
            "description": "Searchable",
            "price": 123.45,
            "stock": 10,
            "category_id": category_id,
        },
    )
    
    # Filter by search term
    response = await client.get("/api/v1/products/?search=Unique Filter")
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert len(data["items"]) >= 1
    assert "Unique Filter Product" in [item["name"] for item in data["items"]]

    # Filter by category
    response = await client.get(f"/api/v1/products/?category_id={category_id}")
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert len(data["items"]) >= 1
    assert all(item["category"]["id"] == category_id for item in data["items"])

    # Filter by price
    response = await client.get("/api/v1/products/?min_price=123&max_price=124")
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert len(data["items"]) >= 1
    assert "Unique Filter Product" in [item["name"] for item in data["items"]]

async def test_delete_product(client: AsyncClient, admin_token_headers: dict, setup_category: dict):
    category_id = setup_category["id"]
    product_data = {
        "name": "Product to Delete",
        "description": "This will be gone",
        "price": 10.00,
        "stock": 1,
        "category_id": category_id,
    }
    create_response = await client.post(
        "/api/v1/products/", headers=admin_token_headers, json=product_data
    )
    product_id = create_response.json()["id"]

    delete_response = await client.delete(
        f"/api/v1/products/{product_id}", headers=admin_token_headers
    )
    assert delete_response.status_code == status.HTTP_200_OK
    assert delete_response.json() == {"msg": "Product deleted successfully"}

    get_response = await client.get(f"/api/v1/products/{product_id}")
    assert get_response.status_code == status.HTTP_404_NOT_FOUND
```
âœ… Streaming completed.